# -*- coding: utf-8 -*-
"""combine_case.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hYZpZfL7kGmtls8AJ3DCKjGG9z5DLe0P
"""

!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf

from google.colab import drive
drive.mount('/content/drive')

"""###<h2>DataLoad"""

import pandas as pd
import numpy as np
train_df = pd.read_csv('/content/drive/MyDrive/lg aimers/train.csv')
test_df = pd.read_csv('/content/drive/MyDrive/lg aimers/test.csv')

# 데이터 합치기
total_data = pd.concat([train_df, test_df], axis=0)

# 각 컬럼의 고유값 확인
for column in total_data.columns:
    print(f"\n[{column}] 고유값:")
    print(total_data[column].unique())
    print(f"고유값 개수: {total_data[column].nunique()}")

"""<h2>Separate"""

def create_treatment_type_columns(data):
    # 기본 시술 유형 리스트
    treatment_types = ['ICSI', 'IVF', 'IUI', 'BLASTOCYST', 'AH',
                      'IVI', 'ICI', 'GIFT', 'FER', 'Generic DI']

    # 결과를 저장할 새로운 데이터프레임 생성
    new_columns = pd.DataFrame(index=data.index)

    # 각 시술 유형별로 확인
    for treatment in treatment_types:
        # 해당 시술이 포함되어 있으면 1, 아니면 0
        new_columns[treatment] = data['특정 시술 유형'].str.contains(treatment, na=False).astype(int)

    # Unknown과 NaN을 하나의 열로 처리
    new_columns['Unknown_or_NaN'] = (
        (data['특정 시술 유형'].isna()) |
        (data['특정 시술 유형'].str.contains('Unknown', na=False))
    ).astype(int)

    return new_columns

# 실행
result = create_treatment_type_columns(train_df)
train_df = pd.concat([train_df, result], axis=1)
result = create_treatment_type_columns(test_df)
test_df = pd.concat([test_df, result], axis=1)

train_df.drop(['특정 시술 유형'], axis=1, inplace=True)
test_df.drop(['특정 시술 유형'], axis=1, inplace=True)

def create_make_type_columns(data):
    # 기본 시술 유형 리스트
    make_types = ['현재 시술용', '난자 저장용', '배아 저장용', '기증용', '연구용']

    # 결과를 저장할 새로운 데이터프레임 생성
    new_columns = pd.DataFrame(index=data.index)

    # 각 시술 유형별로 확인
    for make in make_types:
        # 해당 시술이 포함되어 있으면 1, 아니면 0
        new_columns[make] = data['배아 생성 주요 이유'].str.contains(make, na=False).astype(int)

    # Unknown과 NaN을 하나의 열로 처리
    new_columns['생성_NaN'] = (
        (data['배아 생성 주요 이유'].isna()) |
        (data['배아 생성 주요 이유'].str.contains('Unknown', na=False))
    ).astype(int)

    return new_columns

# 실행
result = create_make_type_columns(train_df)
train_df = pd.concat([train_df, result], axis=1)
result = create_make_type_columns(test_df)
test_df = pd.concat([test_df, result], axis=1)

train_df.drop(['배아 생성 주요 이유'], axis=1, inplace=True)
test_df.drop(['배아 생성 주요 이유'], axis=1, inplace=True)

train_df.columns

# 새로운 '배란 유형' 열 생성
train_df['배란 유형'] = np.where(
    train_df['배란 자극 여부'] == 0, 'A',  # 배란 자극 여부가 0인 경우
    np.where(
        (train_df['배란 자극 여부'] == 1) & (train_df['배란 유도 유형'] == '세트로타이드 (억제제)'), 'B',  # 조건 2
        np.where(
            (train_df['배란 자극 여부'] == 1) & (train_df['배란 유도 유형'] == '생식선 자극 호르몬'), 'C',  # 조건 3
            np.where(
                (train_df['배란 자극 여부'] == 1) &
                ((train_df['배란 유도 유형'] == '기록되지 않은 시행') |
                 (train_df['배란 유도 유형'] == '알 수 없음')),
                # 여기서 NaN 대신 조건에 따라 'B' 또는 'C' 할당
                np.where(
                    (train_df['IVF'] == 1) |
                    (train_df['ICSI'] == 1) |
                    (train_df['미세주입된 난자 수'] > 0) |
                    (train_df['총 생성 배아 수'] >= 5),
                    'B', 'C'
                ),
                # 나머지 경우도 마찬가지로 조건에 따라 'B' 또는 'C' 할당
                np.where(
                    (train_df['IVF'] == 1) |
                    (train_df['ICSI'] == 1) |
                    (train_df['미세주입된 난자 수'] > 0) |
                    (train_df['총 생성 배아 수'] >= 5),
                    'B', 'C'
                )
            )
        )
    )
)

# 새로운 '배란 유형' 열 생성
test_df['배란 유형'] = np.where(
    test_df['배란 자극 여부'] == 0, 'A',  # 배란 자극 여부가 0인 경우
    np.where(
        (test_df['배란 자극 여부'] == 1) & (test_df['배란 유도 유형'] == '세트로타이드 (억제제)'), 'B',  # 조건 2
        np.where(
            (test_df['배란 자극 여부'] == 1) & (test_df['배란 유도 유형'] == '생식선 자극 호르몬'), 'C',  # 조건 3
            np.where(
                (test_df['배란 자극 여부'] == 1) &
                ((test_df['배란 유도 유형'] == '기록되지 않은 시행') |
                 (test_df['배란 유도 유형'] == '알 수 없음')),
                # 여기서 NaN 대신 조건에 따라 'B' 또는 'C' 할당
                np.where(
                    (test_df['IVF'] == 1) |
                    (test_df['ICSI'] == 1) |
                    (test_df['미세주입된 난자 수'] > 0) |
                    (test_df['총 생성 배아 수'] >= 5),
                    'B', 'C'
                ),
                # 나머지 경우도 마찬가지로 조건에 따라 'B' 또는 'C' 할당
                np.where(
                    (test_df['IVF'] == 1) |
                    (test_df['ICSI'] == 1) |
                    (test_df['미세주입된 난자 수'] > 0) |
                    (test_df['총 생성 배아 수'] >= 5),
                    'B', 'C'
                )
            )
        )
    )
)

train_df.drop(['배란 자극 여부'], axis=1, inplace=True)
test_df.drop(['배란 자극 여부'], axis=1, inplace=True)

train_df.drop(['배란 유도 유형'], axis=1, inplace=True)
test_df.drop(['배란 유도 유형'], axis=1, inplace=True)

"""<h3> fill - 유전 검사 원인, 결과"""

# 해당하는 모든 열을 리스트로 저장
columns = ['착상 전 유전 검사 사용 여부', '착상 전 유전 진단 사용 여부', '남성 주 불임 원인',
           '남성 부 불임 원인', '여성 주 불임 원인', '여성 부 불임 원인', '부부 주 불임 원인',
           '부부 부 불임 원인', '불명확 불임 원인', '불임 원인 - 난관 질환', '불임 원인 - 남성 요인',
           '불임 원인 - 배란 장애', '불임 원인 - 여성 요인', '불임 원인 - 자궁경부 문제',
           '불임 원인 - 자궁내막증', '불임 원인 - 정자 농도', '불임 원인 - 정자 면역학적 요인',
           '불임 원인 - 정자 운동성', '불임 원인 - 정자 형태']

# 모든 열이 NaN인 행을 찾아서 마스크 생성
all_train_nan_mask = train_df[columns].isna().all(axis=1)

# 마스크를 사용하여 해당 행들의 열들만 0으로 채우기
train_df.loc[all_train_nan_mask, columns] = 0

all_test_nan_mask = train_df[columns].isna().all(axis=1)

# 마스크를 사용하여 해당 행들의 열들만 0으로 채우기
train_df.loc[all_test_nan_mask, columns] = 0

# 검사할 열 목록
columns = ['남성 주 불임 원인', '남성 부 불임 원인', '여성 주 불임 원인', '여성 부 불임 원인',
           '부부 주 불임 원인', '부부 부 불임 원인', '불명확 불임 원인', '불임 원인 - 난관 질환',
           '불임 원인 - 남성 요인', '불임 원인 - 배란 장애', '불임 원인 - 여성 요인',
           '불임 원인 - 자궁경부 문제', '불임 원인 - 자궁내막증', '불임 원인 - 정자 농도',
           '불임 원인 - 정자 면역학적 요인', '불임 원인 - 정자 운동성', '불임 원인 - 정자 형태']

# 모든 열이 0인 행 찾기
all_zero_mask = (train_df[columns] == 0).all(axis=1)

# 하나라도 1인 행 찾기
any_one_mask = (train_df[columns] == 1).any(axis=1)

# 조건에 따라 '착상 전 유전 진단 사용 여부' 열 업데이트
# 모든 값이 0인 경우 0으로, 하나라도 1이 있는 경우 1로 채우기
train_df.loc[all_zero_mask & train_df['착상 전 유전 진단 사용 여부'].isna(), '착상 전 유전 진단 사용 여부'] = 0
train_df.loc[any_one_mask & train_df['착상 전 유전 진단 사용 여부'].isna(), '착상 전 유전 진단 사용 여부'] = 1

# 모든 열이 0인 행 찾기
all_zero_mask = (test_df[columns] == 0).all(axis=1)

# 하나라도 1인 행 찾기
any_one_mask = (test_df[columns] == 1).any(axis=1)

# 조건에 따라 '착상 전 유전 진단 사용 여부' 열 업데이트
# 모든 값이 0인 경우 0으로, 하나라도 1이 있는 경우 1로 채우기
test_df.loc[all_zero_mask & test_df['착상 전 유전 진단 사용 여부'].isna(), '착상 전 유전 진단 사용 여부'] = 0
test_df.loc[any_one_mask & test_df['착상 전 유전 진단 사용 여부'].isna(), '착상 전 유전 진단 사용 여부'] = 1

# 착상 전 유전 진단 사용 여부가 0이고 착상 전 유전 검사 사용 여부가 NaN인 경우를 찾아 0으로 채우기
mask = (train_df['착상 전 유전 진단 사용 여부'] == 0) & (train_df['착상 전 유전 검사 사용 여부'].isna())
train_df.loc[mask, '착상 전 유전 검사 사용 여부'] = 0
mask = (test_df['착상 전 유전 진단 사용 여부'] == 0) & (test_df['착상 전 유전 검사 사용 여부'].isna())
test_df.loc[mask, '착상 전 유전 검사 사용 여부'] = 0
mask = (train_df['착상 전 유전 진단 사용 여부'] == 1) & (train_df['착상 전 유전 검사 사용 여부'].isna())
train_df.loc[mask, '착상 전 유전 검사 사용 여부'] = 1
mask = (test_df['착상 전 유전 진단 사용 여부'] == 1) & (test_df['착상 전 유전 검사 사용 여부'].isna())
test_df.loc[mask, '착상 전 유전 검사 사용 여부'] = 1

train_df.info()

# 모든 행을 표시하도록 설정
pd.set_option('display.max_rows', None)

# NaN 개수와 비율 계산
nan_info = pd.DataFrame({
    'NaN 개수': test_df.isna().sum(),
    'NaN 비율(%)': (test_df.isna().sum() / len(test_df) * 100).round(2)
})

# 내림차순으로 정렬하여 출력
print(nan_info.sort_values('NaN 개수', ascending=False))

# 설정을 다시 원래대로 되돌리기 (필요한 경우)
pd.reset_option('display.max_rows')

mask = (
    (train_df['PGS 시술 여부'].isna()) &
    (train_df['PGD 시술 여부'].isna()) &
    ((train_df['착상 전 유전 검사 사용 여부'] == 0) |
     (train_df['착상 전 유전 진단 사용 여부'] == 0))
)

# 해당 조건에 맞는 행의 PGS, PGD 시술 여부를 0으로 채우기
train_df.loc[mask, 'PGS 시술 여부'] = 0
train_df.loc[mask, 'PGD 시술 여부'] = 0

mask = (
    (test_df['PGS 시술 여부'].isna()) &
    (test_df['PGD 시술 여부'].isna()) &
    ((test_df['착상 전 유전 검사 사용 여부'] == 0) |
     (test_df['착상 전 유전 진단 사용 여부'] == 0))
)

# 해당 조건에 맞는 행의 PGS, PGD 시술 여부를 0으로 채우기
test_df.loc[mask, 'PGS 시술 여부'] = 0
test_df.loc[mask, 'PGD 시술 여부'] = 0

"""<h3> 난자 해동 경과일 채우기"""

# 1. 해동 과정이 필요없는 경우 확인
no_thaw_mask = (
    (train_df['해동 난자 수'] == 0) |
    (train_df['동결 배아 사용 여부'] == 0) |
    (train_df['FER'] == 0)
)

# 2. 해동 경과일이 있는 데이터의 unique한 값 확인
existing_values = train_df['난자 해동 경과일'].dropna().unique()
print("현재 존재하는 해동 경과일 값:", existing_values)  # [0, 1, 5] 확인

# 3. NaN 값 채우기
# 해동 과정이 필요없는 경우 0으로 채우기
train_df.loc[no_thaw_mask & train_df['난자 해동 경과일'].isna(), '난자 해동 경과일'] = 0

# 나머지 NaN 값에 대해서는 [0, 1, 5] 중에서 적절한 값으로 채우기
# 예를 들어, 중앙값이나 가장 빈번한 값으로 채우기
median_thaw_days = train_df['난자 해동 경과일'].median()
train_df.loc[train_df['난자 해동 경과일'].isna(), '난자 해동 경과일'] = median_thaw_days

# 결과 확인
print("\n값 분포 확인:")
print(train_df['난자 해동 경과일'].value_counts(dropna=False))
def fill_thaw_days(row):
    # 해동 과정이 필요없는 경우
    if (row['해동 난자 수'] == 0 or
        row['동결 배아 사용 여부'] == 0 or
        row['FER'] == 0):
        return 0

    # 이미 값이 있는 경우는 그대로 유지
    if not pd.isna(row['난자 해동 경과일']):
        return row['난자 해동 경과일']

    # 나머지 NaN 케이스에 대한 처리
    if pd.isna(row['난자 해동 경과일']):
        # 여기서 다른 조건들을 확인하여 0, 1, 5 중 적절한 값 할당
        if row['FER'] == 1:  # FER 시술인 경우
            return 1  # 또는 다른 적절한 값
        else:
            return median_thaw_days  # 전체 데이터의 중앙값 사용

# 적용
train_df['난자 해동 경과일'] = train_df.apply(fill_thaw_days, axis=1)

# 1. 해동 과정이 필요없는 경우 확인
no_thaw_mask = (
    (test_df['해동 난자 수'] == 0) |
    (test_df['동결 배아 사용 여부'] == 0) |
    (test_df['FER'] == 0)
)

# 2. 해동 경과일이 있는 데이터의 unique한 값 확인
existing_values = test_df['난자 해동 경과일'].dropna().unique()
print("현재 존재하는 해동 경과일 값:", existing_values)  # [0, 1, 5] 확인

# 3. NaN 값 채우기
# 해동 과정이 필요없는 경우 0으로 채우기
test_df.loc[no_thaw_mask & test_df['난자 해동 경과일'].isna(), '난자 해동 경과일'] = 0

# 나머지 NaN 값에 대해서는 [0, 1, 5] 중에서 적절한 값으로 채우기
# 예를 들어, 중앙값이나 가장 빈번한 값으로 채우기
median_thaw_days = test_df['난자 해동 경과일'].median()
test_df.loc[test_df['난자 해동 경과일'].isna(), '난자 해동 경과일'] = median_thaw_days

# 결과 확인
print("\n값 분포 확인:")
print(test_df['난자 해동 경과일'].value_counts(dropna=False))
def fill_thaw_days(row):
    # 해동 과정이 필요없는 경우
    if (row['해동 난자 수'] == 0 or
        row['동결 배아 사용 여부'] == 0 or
        row['FER'] == 0):
        return 0

    # 이미 값이 있는 경우는 그대로 유지
    if not pd.isna(row['난자 해동 경과일']):
        return row['난자 해동 경과일']

    # 나머지 NaN 케이스에 대한 처리
    if pd.isna(row['난자 해동 경과일']):
        # 여기서 다른 조건들을 확인하여 0, 1, 5 중 적절한 값 할당
        if row['FER'] == 1:  # FER 시술인 경우
            return 1  # 또는 다른 적절한 값
        else:
            return median_thaw_days  # 전체 데이터의 중앙값 사용

# 적용
test_df['난자 해동 경과일'] = test_df.apply(fill_thaw_days, axis=1)

"""<h3>배아 해동 경과일 채워넣기"""

# 1. 배아 해동 과정이 필요없는 경우 확인
no_embryo_thaw_mask = (
    (train_df['해동된 배아 수'] == 0) |
    (train_df['동결 배아 사용 여부'] == 0) |
    (train_df['FER'] == 0) |
    (train_df['신선 배아 사용 여부'] == 1)  # 신선 배아 사용 시 해동 불필요
)

# 2. 해동 경과일이 있는 데이터의 unique한 값 확인
existing_values = train_df['배아 해동 경과일'].dropna().unique()
print("현재 존재하는 배아 해동 경과일 값:", existing_values)

# 3. NaN 값 채우기
# 해동 과정이 필요없는 경우 0으로 채우기
train_df.loc[no_embryo_thaw_mask & train_df['배아 해동 경과일'].isna(), '배아 해동 경과일'] = 0

# 나머지 NaN 값에 대해서는 기존 범위(0~7) 내에서 적절한 값으로 채우기
# 예를 들어, 중앙값으로 채우기
median_embryo_thaw_days = train_df[train_df['배아 해동 경과일'].notna()]['배아 해동 경과일'].median()

# 더 상세한 조건부 채우기를 위한 함수
def fill_embryo_thaw_days(row):
    # 이미 값이 있는 경우는 그대로 유지
    if not pd.isna(row['배아 해동 경과일']):
        return row['배아 해동 경과일']

    # 해동 과정이 필요없는 경우
    if (row['해동된 배아 수'] == 0 or
        row['동결 배아 사용 여부'] == 0 or
        row['FER'] == 0 or
        row['신선 배아 사용 여부'] == 1):
        return 0

    # FER 시술이면서 해동된 배아가 있는 경우
    if row['FER'] == 1 and row['해동된 배아 수'] > 0:
        # 배아 이식 경과일이 있는 경우, 그 값에서 1-2일 정도 뺀 값을 사용
        if not pd.isna(row['배아 이식 경과일']):
            return max(0, row['배아 이식 경과일'] - 2)
        return median_embryo_thaw_days

    # 그 외의 경우 중앙값 사용
    return median_embryo_thaw_days

# 적용
train_df['배아 해동 경과일'] = train_df.apply(fill_embryo_thaw_days, axis=1)

# 결과 확인
print("\n값 분포 확인:")
print(train_df['배아 해동 경과일'].value_counts(dropna=False))

# 1. 배아 해동 과정이 필요없는 경우 확인
no_embryo_thaw_mask = (
    (test_df['해동된 배아 수'] == 0) |
    (test_df['동결 배아 사용 여부'] == 0) |
    (test_df['FER'] == 0) |
    (test_df['신선 배아 사용 여부'] == 1)  # 신선 배아 사용 시 해동 불필요
)

# 2. 해동 경과일이 있는 데이터의 unique한 값 확인
existing_values = test_df['배아 해동 경과일'].dropna().unique()
print("현재 존재하는 배아 해동 경과일 값:", existing_values)

# 3. NaN 값 채우기
# 해동 과정이 필요없는 경우 0으로 채우기
test_df.loc[no_embryo_thaw_mask & test_df['배아 해동 경과일'].isna(), '배아 해동 경과일'] = 0

# 나머지 NaN 값에 대해서는 기존 범위(0~7) 내에서 적절한 값으로 채우기
# 예를 들어, 중앙값으로 채우기
median_embryo_thaw_days = test_df[test_df['배아 해동 경과일'].notna()]['배아 해동 경과일'].median()

# 더 상세한 조건부 채우기를 위한 함수
def fill_embryo_thaw_days(row):
    # 이미 값이 있는 경우는 그대로 유지
    if not pd.isna(row['배아 해동 경과일']):
        return row['배아 해동 경과일']

    # 해동 과정이 필요없는 경우
    if (row['해동된 배아 수'] == 0 or
        row['동결 배아 사용 여부'] == 0 or
        row['FER'] == 0 or
        row['신선 배아 사용 여부'] == 1):
        return 0

    # FER 시술이면서 해동된 배아가 있는 경우
    if row['FER'] == 1 and row['해동된 배아 수'] > 0:
        # 배아 이식 경과일이 있는 경우, 그 값에서 1-2일 정도 뺀 값을 사용
        if not pd.isna(row['배아 이식 경과일']):
            return max(0, row['배아 이식 경과일'] - 2)
        return median_embryo_thaw_days

    # 그 외의 경우 중앙값 사용
    return median_embryo_thaw_days

# 적용
test_df['배아 해동 경과일'] = test_df.apply(fill_embryo_thaw_days, axis=1)

# 결과 확인
print("\n값 분포 확인:")
print(test_df['배아 해동 경과일'].value_counts(dropna=False))

"""<h3>난자 채취 경과일 제거"""

train_df.drop(['난자 채취 경과일'], axis=1, inplace=True)
test_df.drop(['난자 채취 경과일'], axis=1, inplace=True)

"""<h3>난자 혼합 경과일 채워넣기"""

# 1. 난자 혼합 과정이 필요없는 경우 확인
no_mixing_mask = (
    (train_df['혼합된 난자 수'] == 0) |
    (train_df['파트너 정자와 혼합된 난자 수'] == 0) |
    (train_df['기증자 정자와 혼합된 난자 수'] == 0) |
    (train_df['FER'] == 1)  # 동결 배아 이식의 경우 난자 혼합 과정 불필요
)

# 2. 혼합 경과일이 있는 데이터의 unique한 값 확인
existing_values = train_df['난자 혼합 경과일'].dropna().unique()
print("현재 존재하는 난자 혼합 경과일 값:", existing_values)

# 3. 더 상세한 조건부 채우기를 위한 함수
def fill_mixing_days(row):
    # 이미 값이 있는 경우는 그대로 유지
    if not pd.isna(row['난자 혼합 경과일']):
        return row['난자 혼합 경과일']

    # 혼합 과정이 필요없는 경우
    if (row['혼합된 난자 수'] == 0 or
        (row['파트너 정자와 혼합된 난자 수'] == 0 and row['기증자 정자와 혼합된 난자 수'] == 0) or
        row['FER'] == 1):
        return 0

    # 배아 이식이 있는 경우, 그 시점을 기준으로 역산
    if not pd.isna(row['배아 이식 경과일']):
        return max(0, min(7, row['배아 이식 경과일'] - 3))  # 이식 3일 전으로 가정

    # IVF나 ICSI 시술인 경우
    if row['IVF'] == 1 or row['ICSI'] == 1:
        if row['혼합된 난자 수'] > 0:
            return min(7, max(1, row['혼합된 난자 수'] // 5))  # 난자 수에 따라 1~7일 범위 내 값 할당

    # 그 외의 경우 중앙값 사용
    median_mixing_days = train_df[train_df['난자 혼합 경과일'].notna()]['난자 혼합 경과일'].median()
    return median_mixing_days

# 적용
train_df['난자 혼합 경과일'] = train_df.apply(fill_mixing_days, axis=1)

# 결과 확인
print("\n값 분포 확인:")
print(train_df['난자 혼합 경과일'].value_counts(dropna=False))

# 범위 확인 및 조정 (0~7일 범위 보장)
train_df['난자 혼합 경과일'] = train_df['난자 혼합 경과일'].clip(0, 7)

# 1. 난자 혼합 과정이 필요없는 경우 확인
no_mixing_mask = (
    (test_df['혼합된 난자 수'] == 0) |
    (test_df['파트너 정자와 혼합된 난자 수'] == 0) |
    (test_df['기증자 정자와 혼합된 난자 수'] == 0) |
    (test_df['FER'] == 1)  # 동결 배아 이식의 경우 난자 혼합 과정 불필요
)

# 2. 혼합 경과일이 있는 데이터의 unique한 값 확인
existing_values = test_df['난자 혼합 경과일'].dropna().unique()
print("현재 존재하는 난자 혼합 경과일 값:", existing_values)

# 3. 더 상세한 조건부 채우기를 위한 함수
def fill_mixing_days(row):
    # 이미 값이 있는 경우는 그대로 유지
    if not pd.isna(row['난자 혼합 경과일']):
        return row['난자 혼합 경과일']

    # 혼합 과정이 필요없는 경우
    if (row['혼합된 난자 수'] == 0 or
        (row['파트너 정자와 혼합된 난자 수'] == 0 and row['기증자 정자와 혼합된 난자 수'] == 0) or
        row['FER'] == 1):
        return 0

    # 배아 이식이 있는 경우, 그 시점을 기준으로 역산
    if not pd.isna(row['배아 이식 경과일']):
        return max(0, min(7, row['배아 이식 경과일'] - 3))  # 이식 3일 전으로 가정

    # IVF나 ICSI 시술인 경우
    if row['IVF'] == 1 or row['ICSI'] == 1:
        if row['혼합된 난자 수'] > 0:
            return min(7, max(1, row['혼합된 난자 수'] // 5))  # 난자 수에 따라 1~7일 범위 내 값 할당

    # 그 외의 경우 중앙값 사용
    median_mixing_days = test_df[test_df['난자 혼합 경과일'].notna()]['난자 혼합 경과일'].median()
    return median_mixing_days

# 적용
test_df['난자 혼합 경과일'] = test_df.apply(fill_mixing_days, axis=1)

# 결과 확인
print("\n값 분포 확인:")
print(test_df['난자 혼합 경과일'].value_counts(dropna=False))

# 범위 확인 및 조정 (0~7일 범위 보장)
test_df['난자 혼합 경과일'] = test_df['난자 혼합 경과일'].clip(0, 7)

"""<h3>배아 이식 경과일 채우기"""

# 1. 배아 이식 과정이 필요없는 경우 확인
no_embryo_transfer_mask = (
    (train_df['이식된 배아 수'] == 0) |  # 이식된 배아가 없는 경우
    (train_df['혼합된 난자 수'] == 0) |   # 혼합된 난자가 없는 경우
    ((train_df['파트너 정자와 혼합된 난자 수'] == 0) & (train_df['기증자 정자와 혼합된 난자 수'] == 0))  # 정자와 혼합되지 않은 경우
)

# 2. 해동 경과일이 있는 데이터의 unique한 값 확인
existing_values = train_df['배아 이식 경과일'].dropna().unique()
print("현재 존재하는 배아 이식 경과일 값:", existing_values)

# 3. 더 상세한 조건부 채우기를 위한 함수
def fill_embryo_transfer_days(row):
    # 이미 값이 있는 경우는 그대로 유지
    if not pd.isna(row['배아 이식 경과일']):
        return row['배아 이식 경과일']

    # 이식 과정이 필요없는 경우
    if ((row['이식된 배아 수'] == 0) or
        (row['혼합된 난자 수'] == 0) or
        ((row['파트너 정자와 혼합된 난자 수'] == 0) and (row['기증자 정자와 혼합된 난자 수'] == 0))):
        return 0

    # 난자 혼합 경과일이 있는 경우, 그 값에 기반하여 설정
    if not pd.isna(row['난자 혼합 경과일']):
        return min(7, row['난자 혼합 경과일'] + 2)  # 혼합 후 2일 정도 후에 이식

    # 배아 해동 경과일이 있는 경우
    if not pd.isna(row['배아 해동 경과일']) and row['배아 해동 경과일'] > 0:
        return min(7, row['배아 해동 경과일'] + 1)  # 해동 후 1일 정도 후에 이식

    # 그 외의 경우 중앙값 사용
    median_transfer_days = train_df[train_df['배아 이식 경과일'].notna()]['배아 이식 경과일'].median()
    return median_transfer_days

# 적용
train_df['배아 이식 경과일'] = train_df.apply(fill_embryo_transfer_days, axis=1)

# 4. 값이 0~7 범위를 벗어나는 경우 조정
train_df['배아 이식 경과일'] = train_df['배아 이식 경과일'].clip(0, 7)

# 결과 확인
print("\n값 분포 확인:")
print(train_df['배아 이식 경과일'].value_counts(dropna=False))

# 1. 배아 이식 과정이 필요없는 경우 확인
no_embryo_transfer_mask = (
    (test_df['이식된 배아 수'] == 0) |  # 이식된 배아가 없는 경우
    (test_df['혼합된 난자 수'] == 0) |   # 혼합된 난자가 없는 경우
    ((test_df['파트너 정자와 혼합된 난자 수'] == 0) & (test_df['기증자 정자와 혼합된 난자 수'] == 0))  # 정자와 혼합되지 않은 경우
)

# 2. 해동 경과일이 있는 데이터의 unique한 값 확인
existing_values = test_df['배아 이식 경과일'].dropna().unique()
print("현재 존재하는 배아 이식 경과일 값:", existing_values)

# 3. 더 상세한 조건부 채우기를 위한 함수
def fill_embryo_transfer_days(row):
    # 이미 값이 있는 경우는 그대로 유지
    if not pd.isna(row['배아 이식 경과일']):
        return row['배아 이식 경과일']

    # 이식 과정이 필요없는 경우
    if ((row['이식된 배아 수'] == 0) or
        (row['혼합된 난자 수'] == 0) or
        ((row['파트너 정자와 혼합된 난자 수'] == 0) and (row['기증자 정자와 혼합된 난자 수'] == 0))):
        return 0

    # 난자 혼합 경과일이 있는 경우, 그 값에 기반하여 설정
    if not pd.isna(row['난자 혼합 경과일']):
        return min(7, row['난자 혼합 경과일'] + 2)  # 혼합 후 2일 정도 후에 이식

    # 배아 해동 경과일이 있는 경우
    if not pd.isna(row['배아 해동 경과일']) and row['배아 해동 경과일'] > 0:
        return min(7, row['배아 해동 경과일'] + 1)  # 해동 후 1일 정도 후에 이식

    # 그 외의 경우 중앙값 사용
    median_transfer_days = test_df[test_df['배아 이식 경과일'].notna()]['배아 이식 경과일'].median()
    return median_transfer_days

# 적용
test_df['배아 이식 경과일'] = test_df.apply(fill_embryo_transfer_days, axis=1)

# 4. 값이 0~7 범위를 벗어나는 경우 조정
test_df['배아 이식 경과일'] = test_df['배아 이식 경과일'].clip(0, 7)

# 결과 확인
print("\n값 분포 확인:")
print(test_df['배아 이식 경과일'].value_counts(dropna=False))

"""<h3> PGS, PGD 시술여부 채우기"""

# PGS 시술 여부와 PGD 시술 여부의 NaN을 1로 채우기
train_df['PGS 시술 여부'] = train_df['PGS 시술 여부'].fillna(1)
train_df['PGD 시술 여부'] = train_df['PGD 시술 여부'].fillna(1)

# 결과 확인
print("\nPGS 시술 여부 값 분포:")
print(train_df['PGS 시술 여부'].value_counts(dropna=False))
print("\nPGD 시술 여부 값 분포:")
print(train_df['PGD 시술 여부'].value_counts(dropna=False))

# PGS 시술 여부와 PGD 시술 여부의 NaN을 1로 채우기
test_df['PGS 시술 여부'] = test_df['PGS 시술 여부'].fillna(1)
test_df['PGD 시술 여부'] = test_df['PGD 시술 여부'].fillna(1)

# 결과 확인
print("\nPGS 시술 여부 값 분포:")
print(test_df['PGS 시술 여부'].value_counts(dropna=False))
print("\nPGD 시술 여부 값 분포:")
print(test_df['PGD 시술 여부'].value_counts(dropna=False))

"""<h3>특이 케이스 6291행 채우기"""

# 해당 열들을 리스트로 정의
columns_to_check = [
    '미세주입 후 저장된 배아 수', '이식된 배아 수', '기증 배아 사용 여부',
    '신선 배아 사용 여부', '동결 배아 사용 여부', '총 생성 배아 수',
    '미세주입된 난자 수', '미세주입에서 생성된 배아 수', '미세주입 배아 이식 수',
    '기증자 정자와 혼합된 난자 수', '저장된 배아 수', '해동된 배아 수',
    '해동 난자 수', '수집된 신선 난자 수', '저장된 신선 난자 수',
    '혼합된 난자 수', '대리모 여부', '파트너 정자와 혼합된 난자 수',
    '단일 배아 이식 여부'
]

# 모든 열이 NaN인 행 확인
all_nan_mask = train_df[columns_to_check].isna().all(axis=1)
problematic_rows = train_df[all_nan_mask]

# 해당 행들의 다른 특성 확인
print("문제가 되는 행들의 다른 특성:")
print(problematic_rows[['시술 유형', '임신 성공 여부', 'ICSI', 'IVF', 'IUI', 'BLASTOCYST']].head())
# 1) 시술 유형에 따른 기본값 설정
def fill_based_on_procedure(row):
    if row['IVF'] == 1:
        return {
            '미세주입된 난자 수': 0,
            '이식된 배아 수': 1,  # 기본적으로 1개 이식 가정
            '총 생성 배아 수': 1,
            '단일 배아 이식 여부': 1
        }
    elif row['ICSI'] == 1:
        return {
            '미세주입된 난자 수': 1,
            '이식된 배아 수': 1,
            '총 생성 배아 수': 1,
            '단일 배아 이식 여부': 1
        }
    # 다른 시술 유형에 대한 기본값 추가
    return {}

# 2) 기본값으로 채우기
for idx in problematic_rows.index:
    default_values = fill_based_on_procedure(train_df.loc[idx])
    for col, val in default_values.items():
        train_df.loc[idx, col] = val

    # 나머지 열들은 0으로 채우기
    for col in columns_to_check:
        if pd.isna(train_df.loc[idx, col]):
            train_df.loc[idx, col] = 0

# 3) 검증
print("\n처리 후 NaN 값 개수:")
print(train_df[columns_to_check].isna().sum())

# 해당 열들을 리스트로 정의
columns_to_check = [
    '미세주입 후 저장된 배아 수', '이식된 배아 수', '기증 배아 사용 여부',
    '신선 배아 사용 여부', '동결 배아 사용 여부', '총 생성 배아 수',
    '미세주입된 난자 수', '미세주입에서 생성된 배아 수', '미세주입 배아 이식 수',
    '기증자 정자와 혼합된 난자 수', '저장된 배아 수', '해동된 배아 수',
    '해동 난자 수', '수집된 신선 난자 수', '저장된 신선 난자 수',
    '혼합된 난자 수', '대리모 여부', '파트너 정자와 혼합된 난자 수',
    '단일 배아 이식 여부'
]

# 모든 열이 NaN인 행 확인
all_nan_mask = test_df[columns_to_check].isna().all(axis=1)
problematic_rows = test_df[all_nan_mask]

# 해당 행들의 다른 특성 확인
print("문제가 되는 행들의 다른 특성:")
print(problematic_rows[['시술 유형', 'ICSI', 'IVF', 'IUI', 'BLASTOCYST']].head())
# 1) 시술 유형에 따른 기본값 설정
def fill_based_on_procedure(row):
    if row['IVF'] == 1:
        return {
            '미세주입된 난자 수': 0,
            '이식된 배아 수': 1,  # 기본적으로 1개 이식 가정
            '총 생성 배아 수': 1,
            '단일 배아 이식 여부': 1
        }
    elif row['ICSI'] == 1:
        return {
            '미세주입된 난자 수': 1,
            '이식된 배아 수': 1,
            '총 생성 배아 수': 1,
            '단일 배아 이식 여부': 1
        }
    # 다른 시술 유형에 대한 기본값 추가
    return {}

# 2) 기본값으로 채우기
for idx in problematic_rows.index:
    default_values = fill_based_on_procedure(test_df.loc[idx])
    for col, val in default_values.items():
        test_df.loc[idx, col] = val

    # 나머지 열들은 0으로 채우기
    for col in columns_to_check:
        if pd.isna(test_df.loc[idx, col]):
            test_df.loc[idx, col] = 0

# 3) 검증
print("\n처리 후 NaN 값 개수:")
print(test_df[columns_to_check].isna().sum())

# '알 수 없음'을 NaN으로 대체
train_df = train_df.replace('알 수 없음', np.nan)
test_df = test_df.replace('알 수 없음', np.nan)

# 모든 행을 표시하도록 설정
pd.set_option('display.max_rows', None)

# NaN 개수와 비율 계산
nan_info = pd.DataFrame({
    'NaN 개수': test_df.isna().sum(),
    'NaN 비율(%)': (test_df.isna().sum() / len(test_df) * 100).round(2)
})

# 내림차순으로 정렬하여 출력
print(nan_info.sort_values('NaN 개수', ascending=False))

# 설정을 다시 원래대로 되돌리기 (필요한 경우)
pd.reset_option('display.max_rows')

"""<h3>임신 시도 또는 마지막 임신 경과 연수 채워기"""

import pandas as pd
import numpy as np
from sklearn.impute import KNNImputer
import gc

# 경고 메시지 처리
pd.set_option('future.no_silent_downcasting', True)

# 나이 변환
age_map = {
    '만18-34세': 26, '만35-37세': 36, '만38-39세': 38.5,
    '만40-42세': 41, '만43-44세': 43.5, '만45-50세': 47.5
}
numeric_age = train_df['시술 당시 나이'].replace(age_map).infer_objects(copy=False)

# 시술 횟수 변환 (벡터화)
numeric_features = {}
numeric_cols = ['총 시술 횟수', '클리닉 내 총 시술 횟수', 'IVF 시술 횟수',
                'DI 시술 횟수', '총 임신 횟수', 'IVF 임신 횟수',
                'DI 임신 횟수', '총 출산 횟수', 'IVF 출산 횟수', 'DI 출산 횟수']
for col in numeric_cols:
    numeric_features[col] = pd.to_numeric(
        train_df[col].replace({'6회 이상': '6', '회': ''}, regex=True),
        errors='coerce'
    ).astype('int8')

infertility_cols = ['남성 주 불임 원인', '남성 부 불임 원인', '여성 주 불임 원인', '여성 부 불임 원인',
                    '부부 주 불임 원인', '부부 부 불임 원인', '불명확 불임 원인',
                    '불임 원인 - 난관 질환', '불임 원인 - 남성 요인', '불임 원인 - 배란 장애',
                    '불임 원인 - 여성 요인', '불임 원인 - 자궁경부 문제', '불임 원인 - 자궁내막증',
                    '불임 원인 - 정자 농도', '불임 원인 - 정자 면역학적 요인', '불임 원인 - 정자 운동성',
                    '불임 원인 - 정자 형태']

# 불임 원인 열 최적화
for col in infertility_cols:
    train_df[col] = train_df[col].astype('bool')

# 결측치 처리
missing_mask = train_df['임신 시도 또는 마지막 임신 경과 연수'].isna()
if missing_mask.sum() > 0:
    imputation_df = pd.DataFrame({
        '시술 당시 나이': numeric_age[missing_mask],
        **{k: v[missing_mask] for k, v in numeric_features.items()},
        **{col: train_df[col][missing_mask] for col in infertility_cols}
    })

    # n_jobs 파라미터 제거
    imputer = KNNImputer(n_neighbors=5)
    imputed_values = imputer.fit_transform(imputation_df)
    train_df.loc[missing_mask, '임신 시도 또는 마지막 임신 경과 연수'] = imputed_values[:, -1]

    del imputation_df
    gc.collect()

# 최종 처리
train_df['임신 시도 또는 마지막 임신 경과 연수'] = np.clip(
    train_df['임신 시도 또는 마지막 임신 경과 연수'].round(0), 0, 20
)

print("\n채운 후 통계:")
print(train_df['임신 시도 또는 마지막 임신 경과 연수'].describe())

import pandas as pd
import numpy as np
from sklearn.impute import KNNImputer
import gc

# 경고 메시지 처리
pd.set_option('future.no_silent_downcasting', True)

# 나이 변환
age_map = {
    '만18-34세': 26, '만35-37세': 36, '만38-39세': 38.5,
    '만40-42세': 41, '만43-44세': 43.5, '만45-50세': 47.5
}
numeric_age = test_df['시술 당시 나이'].replace(age_map).infer_objects(copy=False)

# 시술 횟수 변환 (벡터화)
numeric_features = {}
for col in numeric_cols:
    numeric_features[col] = pd.to_numeric(
        test_df[col].replace({'6회 이상': '6', '회': ''}, regex=True),
        errors='coerce'
    ).astype('int8')

# 불임 원인 열 최적화
for col in infertility_cols:
    test_df[col] = test_df[col].astype('bool')

# 결측치 처리
missing_mask = test_df['임신 시도 또는 마지막 임신 경과 연수'].isna()
if missing_mask.sum() > 0:
    imputation_df = pd.DataFrame({
        '시술 당시 나이': numeric_age[missing_mask],
        **{k: v[missing_mask] for k, v in numeric_features.items()},
        **{col: test_df[col][missing_mask] for col in infertility_cols}
    })

    # n_jobs 파라미터 제거
    imputer = KNNImputer(n_neighbors=5)
    imputed_values = imputer.fit_transform(imputation_df)
    test_df.loc[missing_mask, '임신 시도 또는 마지막 임신 경과 연수'] = imputed_values[:, -1]

    del imputation_df
    gc.collect()

# 최종 처리
test_df['임신 시도 또는 마지막 임신 경과 연수'] = np.clip(
    test_df['임신 시도 또는 마지막 임신 경과 연수'].round(0), 0, 20
)

print("\n채운 후 통계:")
print(train_df['임신 시도 또는 마지막 임신 경과 연수'].describe())

import numpy as np
import random

# 난자 기증자 나이 처리 함수
def fill_egg_donor_age(row):
    # 난자를 기증받지 않은 경우 (난자 출처가 '본인 제공'인 경우)
    if row['난자 출처'] == '본인 제공':
        return '기증 받지 않음'
    # 난자를 기증받은 경우 (난자 출처가 '기증 제공'인 경우)
    elif row['난자 출처'] == '기증 제공':
        donor_ages = ['만21-25세', '만31-35세', '만26-30세', '만20세 이하']
        if pd.isna(row['난자 기증자 나이']):
            return random.choice(donor_ages)
        return row['난자 기증자 나이']
    # 그 외의 경우 (NaN 포함)
    else:
        return row['난자 기증자 나이']

# 정자 기증자 나이 처리 함수
def fill_sperm_donor_age(row):
    # 정자를 기증받지 않은 경우 (정자 출처가 '배우자 제공'인 경우)
    if row['정자 출처'] == '배우자 제공':
        return '기증 받지 않음'
    # 정자를 기증받은 경우
    elif row['정자 출처'] in ['기증 제공', '배우자 및 기증 제공']:
        donor_ages = ['만26-30세', '만21-25세', '만41-45세', '만36-40세', '만31-35세', '만20세 이하']
        if pd.isna(row['정자 기증자 나이']):
            return random.choice(donor_ages)
        return row['정자 기증자 나이']
    # 그 외의 경우 (NaN 포함)
    else:
        return row['정자 기증자 나이']

# 난자 출처 처리 함수
def fill_egg_source(row):
    if pd.isna(row['난자 출처']):
        # 난자를 사용하지 않은 경우
        if row['수집된 신선 난자 수'] == 0 and row['해동 난자 수'] == 0:
            return '미할당'
        # 난자를 사용한 경우
        else:
            return random.choice(['본인 제공', '기증 제공'])
    return row['난자 출처']

# 시술 당시 나이 처리 함수
def fill_treatment_age(row):
    # 시술을 받지 않은 경우 체크
    if (row['총 시술 횟수'] == '0회' or pd.isna(row['총 시술 횟수'])):
        return '받지 않음'

    age_ranges = ['만18-34세', '만45-50세', '만35-37세', '만38-39세', '만40-42세', '만43-44세']
    if pd.isna(row['시술 당시 나이']) or row['시술 당시 나이'] == '알 수 없음':
        return random.choice(age_ranges)
    return row['시술 당시 나이']

# 데이터 채우기 적용
train_df['난자 기증자 나이'] = train_df.apply(fill_egg_donor_age, axis=1)
train_df['정자 기증자 나이'] = train_df.apply(fill_sperm_donor_age, axis=1)
train_df['난자 출처'] = train_df.apply(fill_egg_source, axis=1)
train_df['시술 당시 나이'] = train_df.apply(fill_treatment_age, axis=1)

# 결과 확인
print("\n난자 기증자 나이 분포:")
print(train_df['난자 기증자 나이'].value_counts())
print("\n정자 기증자 나이 분포:")
print(train_df['정자 기증자 나이'].value_counts())
print("\n난자 출처 분포:")
print(train_df['난자 출처'].value_counts())
print("\n시술 당시 나이 분포:")
print(train_df['시술 당시 나이'].value_counts())

import numpy as np
import random

# 난자 기증자 나이 처리 함수
def fill_egg_donor_age(row):
    # 난자를 기증받지 않은 경우 (난자 출처가 '본인 제공'인 경우)
    if row['난자 출처'] == '본인 제공':
        return '기증 받지 않음'
    # 난자를 기증받은 경우 (난자 출처가 '기증 제공'인 경우)
    elif row['난자 출처'] == '기증 제공':
        donor_ages = ['만21-25세', '만31-35세', '만26-30세', '만20세 이하']
        if pd.isna(row['난자 기증자 나이']):
            return random.choice(donor_ages)
        return row['난자 기증자 나이']
    # 그 외의 경우 (NaN 포함)
    else:
        return row['난자 기증자 나이']

# 정자 기증자 나이 처리 함수
def fill_sperm_donor_age(row):
    # 정자를 기증받지 않은 경우 (정자 출처가 '배우자 제공'인 경우)
    if row['정자 출처'] == '배우자 제공':
        return '기증 받지 않음'
    # 정자를 기증받은 경우
    elif row['정자 출처'] in ['기증 제공', '배우자 및 기증 제공']:
        donor_ages = ['만26-30세', '만21-25세', '만41-45세', '만36-40세', '만31-35세', '만20세 이하']
        if pd.isna(row['정자 기증자 나이']):
            return random.choice(donor_ages)
        return row['정자 기증자 나이']
    # 그 외의 경우 (NaN 포함)
    else:
        return row['정자 기증자 나이']

# 난자 출처 처리 함수
def fill_egg_source(row):
    if pd.isna(row['난자 출처']):
        # 난자를 사용하지 않은 경우
        if row['수집된 신선 난자 수'] == 0 and row['해동 난자 수'] == 0:
            return '미할당'
        # 난자를 사용한 경우
        else:
            return random.choice(['본인 제공', '기증 제공'])
    return row['난자 출처']

# 시술 당시 나이 처리 함수
def fill_treatment_age(row):
    # 시술을 받지 않은 경우 체크
    if (row['총 시술 횟수'] == '0회' or pd.isna(row['총 시술 횟수'])):
        return '받지 않음'

    age_ranges = ['만18-34세', '만45-50세', '만35-37세', '만38-39세', '만40-42세', '만43-44세']
    if pd.isna(row['시술 당시 나이']) or row['시술 당시 나이'] == '알 수 없음':
        return random.choice(age_ranges)
    return row['시술 당시 나이']

# 데이터 채우기 적용
test_df['난자 기증자 나이'] = test_df.apply(fill_egg_donor_age, axis=1)
test_df['정자 기증자 나이'] = test_df.apply(fill_sperm_donor_age, axis=1)
test_df['난자 출처'] = test_df.apply(fill_egg_source, axis=1)
test_df['시술 당시 나이'] = test_df.apply(fill_treatment_age, axis=1)

# 결과 확인
print("\n난자 기증자 나이 분포:")
print(test_df['난자 기증자 나이'].value_counts())
print("\n정자 기증자 나이 분포:")
print(test_df['정자 기증자 나이'].value_counts())
print("\n난자 출처 분포:")
print(test_df['난자 출처'].value_counts())
print("\n시술 당시 나이 분포:")
print(test_df['시술 당시 나이'].value_counts())

# 데이터 합치기
total_data = pd.concat([train_df, test_df], axis=0)

# 각 컬럼의 고유값 확인
for column in total_data.columns:
    print(f"\n[{column}] 고유값:")
    print(total_data[column].unique())
    print(f"고유값 개수: {total_data[column].nunique()}")

# 모든 행을 표시하도록 설정
pd.set_option('display.max_rows', None)

# NaN 개수와 비율 계산
nan_info = pd.DataFrame({
    'NaN 개수': train_df.isna().sum(),
    'NaN 비율(%)': (train_df.isna().sum() / len(train_df) * 100).round(2)
})

# 내림차순으로 정렬하여 출력
print(nan_info.sort_values('NaN 개수', ascending=False))

# 설정을 다시 원래대로 되돌리기 (필요한 경우)
pd.reset_option('display.max_rows')

"""<h3>난자기증자 나이, 정자기증자 나이 채워넣기"""

# 난자 기증자 나이 처리 함수
def fill_egg_donor_age(row):
    # 난자를 기증받지 않은 경우 (난자 출처가 '본인 제공'인 경우)
    if row['난자 출처'] == '본인 제공':
        return '기증 받지 않음'
    # 난자를 기증받은 경우 (난자 출처가 '기증 제공'인 경우)
    elif row['난자 출처'] == '기증 제공':
        donor_ages = ['만21-25세', '만31-35세', '만26-30세', '만20세 이하']
        if pd.isna(row['난자 기증자 나이']) or row['난자 기증자 나이'] == '알 수 없음':
            return random.choice(donor_ages)
        return row['난자 기증자 나이']
    # 그 외의 경우 (NaN이나 '알 수 없음' 포함)
    else:
        if pd.isna(row['난자 기증자 나이']):
            return '기증 받지 않음'
        return row['난자 기증자 나이']

# 정자 기증자 나이 처리 함수
def fill_sperm_donor_age(row):
    # 정자를 기증받지 않은 경우 (정자 출처가 '배우자 제공'인 경우)
    if row['정자 출처'] == '배우자 제공':
        return '기증 받지 않음'
    # 정자를 기증받은 경우
    elif row['정자 출처'] in ['기증 제공', '배우자 및 기증 제공']:
        donor_ages = ['만26-30세', '만21-25세', '만41-45세', '만36-40세', '만31-35세', '만20세 이하']
        if pd.isna(row['정자 기증자 나이']) or row['정자 기증자 나이'] == '알 수 없음':
            return random.choice(donor_ages)
        return row['정자 기증자 나이']
    # 그 외의 경우 (NaN이나 '알 수 없음' 포함)
    else:
        if pd.isna(row['정자 기증자 나이']):
            return '기증 받지 않음'
        return row['정자 기증자 나이']

# 데이터 채우기 적용
train_df['난자 기증자 나이'] = train_df.apply(fill_egg_donor_age, axis=1)
train_df['정자 기증자 나이'] = train_df.apply(fill_sperm_donor_age, axis=1)

# 결과 확인
print("\n난자 기증자 나이 분포:")
print(train_df['난자 기증자 나이'].value_counts())
print("\n정자 기증자 나이 분포:")
print(train_df['정자 기증자 나이'].value_counts())

# 난자 기증자 나이 처리 함수
def fill_egg_donor_age(row):
    # 난자를 기증받지 않은 경우 (난자 출처가 '본인 제공'인 경우)
    if row['난자 출처'] == '본인 제공':
        return '기증 받지 않음'
    # 난자를 기증받은 경우 (난자 출처가 '기증 제공'인 경우)
    elif row['난자 출처'] == '기증 제공':
        donor_ages = ['만21-25세', '만31-35세', '만26-30세', '만20세 이하']
        if pd.isna(row['난자 기증자 나이']) or row['난자 기증자 나이'] == '알 수 없음':
            return random.choice(donor_ages)
        return row['난자 기증자 나이']
    # 그 외의 경우 (NaN이나 '알 수 없음' 포함)
    else:
        if pd.isna(row['난자 기증자 나이']):
            return '기증 받지 않음'
        return row['난자 기증자 나이']

# 정자 기증자 나이 처리 함수
def fill_sperm_donor_age(row):
    # 정자를 기증받지 않은 경우 (정자 출처가 '배우자 제공'인 경우)
    if row['정자 출처'] == '배우자 제공':
        return '기증 받지 않음'
    # 정자를 기증받은 경우
    elif row['정자 출처'] in ['기증 제공', '배우자 및 기증 제공']:
        donor_ages = ['만26-30세', '만21-25세', '만41-45세', '만36-40세', '만31-35세', '만20세 이하']
        if pd.isna(row['정자 기증자 나이']) or row['정자 기증자 나이'] == '알 수 없음':
            return random.choice(donor_ages)
        return row['정자 기증자 나이']
    # 그 외의 경우 (NaN이나 '알 수 없음' 포함)
    else:
        if pd.isna(row['정자 기증자 나이']):
            return '기증 받지 않음'
        return row['정자 기증자 나이']

# 데이터 채우기 적용
test_df['난자 기증자 나이'] = test_df.apply(fill_egg_donor_age, axis=1)
test_df['정자 기증자 나이'] = test_df.apply(fill_sperm_donor_age, axis=1)

# 결과 확인
print("\n난자 기증자 나이 분포:")
print(test_df['난자 기증자 나이'].value_counts())
print("\n정자 기증자 나이 분포:")
print(test_df['정자 기증자 나이'].value_counts())

"""<h2>Unknown 속성열 대체 및 삭제"""

import pandas as pd
import numpy as np

def classify_unknown_treatments(df):
    """
    Unknown_or_NaN이 1인 행들을 다른 속성을 기반으로 적절한 시술 유형으로 분류
    """
    # 분류에 사용할 컬럼들
    treatment_columns = ['ICSI', 'IVF', 'IUI', 'BLASTOCYST', 'AH', 'IVI', 'ICI', 'GIFT', 'FER', 'Generic DI']

    # Unknown_or_NaN이 1인 행들의 인덱스
    unknown_rows = df[df['Unknown_or_NaN'] == 1].index

    for idx in unknown_rows:
        row = df.loc[idx]

        # 분류 로직 시작
        if row['시술 유형'] == 'IVF':
            if row['착상 전 유전 검사 사용 여부'] == 1:
                df.loc[idx, 'BLASTOCYST'] = 1
            elif row['미세주입된 난자 수'] > 0:
                df.loc[idx, 'ICSI'] = 1
            else:
                df.loc[idx, 'IVF'] = 1

        elif row['시술 유형'] == 'DI':
            if row['정자 출처'] == '기증 제공':
                df.loc[idx, 'Generic DI'] = 1
            elif row['IUI'] == 1:
                df.loc[idx, 'IUI'] = 1
            else:
                df.loc[idx, 'ICI'] = 1

        # 특수한 경우들
        if row['동결 배아 사용 여부'] == 1:
            df.loc[idx, 'FER'] = 1

        if row['착상 전 유전 진단 사용 여부'] == 1:
            df.loc[idx, 'AH'] = 1

        # Unknown_or_NaN 값을 0으로 변경
        df.loc[idx, 'Unknown_or_NaN'] = 0

    return df

def verify_classification(df):
    """
    분류 결과 검증 및 Unknown_or_NaN 열 제거
    Unknown_or_NaN이 모두 처리되었는지 확인한 후 해당 열을 제거합니다.
    """
    # Unknown_or_NaN이 1인 행이 남아있는지 확인
    remaining_unknown = df['Unknown_or_NaN'].sum()

    # 각 행이 최소 하나의 시술 유형을 가지고 있는지 확인
    treatment_columns = ['ICSI', 'IVF', 'IUI', 'BLASTOCYST', 'AH', 'IVI', 'ICI', 'GIFT', 'FER', 'Generic DI']
    rows_without_treatment = df[df[treatment_columns].sum(axis=1) == 0].shape[0]

    # 모든 Unknown이 처리되었는지 확인
    if remaining_unknown == 0:
        # Unknown_or_NaN 열 제거
        df = df.drop('Unknown_or_NaN', axis=1)
        return {
            'status': 'success',
            'message': 'All unknown cases classified and column removed',
            'rows_without_treatment': rows_without_treatment
        }
    else:
        return {
            'status': 'error',
            'message': f'There are still {remaining_unknown} unclassified cases',
            'remaining_unknown': remaining_unknown,
            'rows_without_treatment': rows_without_treatment
        }

# 데이터 분류 실행
train_df = classify_unknown_treatments(train_df)

# 검증 및 Unknown_or_NaN 열 제거
result = verify_classification(train_df)

if result['status'] == 'success':
    print("분류 완료 및 Unknown_or_NaN 열이 제거되었습니다.")
    print(f"처리 유형이 없는 행 수: {result['rows_without_treatment']}")
else:
    print(f"오류: {result['message']}")
    print(f"미분류 케이스 수: {result['remaining_unknown']}")

# 데이터 분류 실행
test_df = classify_unknown_treatments(test_df)

# 검증 및 Unknown_or_NaN 열 제거
result = verify_classification(test_df)

if result['status'] == 'success':
    print("분류 완료 및 Unknown_or_NaN 열이 제거되었습니다.")
    print(f"처리 유형이 없는 행 수: {result['rows_without_treatment']}")
else:
    print(f"오류: {result['message']}")
    print(f"미분류 케이스 수: {result['remaining_unknown']}")

train_df.drop(['Unknown_or_NaN'], axis=1, inplace=True)
test_df.drop(['Unknown_or_NaN'], axis=1, inplace=True)

"""<h2> 생성 NaN을 대체 및 제거하기"""

import pandas as pd
import numpy as np

def classify_nan_rows(df):
    """
    생성_NaN이 1인 행들을 다른 특성을 기반으로 분류하여
    적절한 용도 컬럼의 값을 증가시키는 함수
    """
    # 생성_NaN이 1인 행들의 인덱스를 찾습니다
    nan_rows = df[df['생성_NaN'] == 1].index

    # 각 행에 대해 분류를 수행합니다
    for idx in nan_rows:
        row = df.loc[idx]

        # 1. 현재 시술용으로 분류
        if ((row['IVF'] == 1 or row['ICSI'] == 1) and
            row['총 시술 횟수'] != '0회' and
            row['이식된 배아 수'] > 0):
            df.at[idx, '현재 시술용'] = 1

        # 2. 배아 저장용으로 분류
        elif (row['저장된 배아 수'] > 0 or
              row['미세주입 후 저장된 배아 수'] > 0):
            df.at[idx, '배아 저장용'] = 1

        # 3. 난자 저장용으로 분류
        elif (row['저장된 신선 난자 수'] > 0 and
              row['난자 출처'] == '본인 제공'):
            df.at[idx, '난자 저장용'] = 1

        # 4. 기증용으로 분류
        elif (row['난자 출처'] == '기증 제공' or
              row['정자 출처'] == '기증 제공'):
            df.at[idx, '기증용'] = 1

        # 5. 연구용으로 분류 (다른 조건에 해당하지 않는 경우)
        else:
            df.at[idx, '연구용'] = 1

    # 생성_NaN 컬럼을 0으로 업데이트
    df.loc[nan_rows, '생성_NaN'] = 0

    return df

train_df = classify_nan_rows(train_df)
test_df = classify_nan_rows(test_df)

train_df.drop(['생성_NaN'], axis=1, inplace=True)
test_df.drop(['생성_NaN'], axis=1, inplace=True)

"""<h2> 내용 범주화 및 밑작업"""

import pandas as pd
import numpy as np

class DataTransformer:
    def __init__(self, train_data, target_column='임신 성공 여부', exclude_cols=None, unknown_values=None):
        self.target_column = target_column
        self.exclude_cols = exclude_cols or []
        self.unknown_values = unknown_values or ['알 수 없음', 'Unknown', 'NA', 'N/A']
        self.transformation_details = {}
        self.bin_edges_dict, self.value_mapping_dict, self.bin_probabilities = self._generate_transformation_info(train_data)

    def _replace_unknown_values(self, data):
        data = data.copy()
        for column in data.columns:
            if column not in self.exclude_cols and column != self.target_column:
                mask = data[column].astype(str).str.lower().isin([str(val).lower() for val in self.unknown_values])
                data.loc[mask, column] = np.nan
        return data

    def _calculate_probability_based_bins(self, series, target_series, n_bins=5):
        valid_mask = series.notna() & target_series.notna()
        valid_series = series[valid_mask]
        valid_target = target_series[valid_mask]

        if len(valid_series) == 0:
            return None, None

        # 초기 구간 생성
        percentiles = np.linspace(0, 100, n_bins + 1)
        bin_edges = np.percentile(valid_series, percentiles)
        bin_edges[0] = -np.inf
        bin_edges[-1] = np.inf

        # 각 구간의 타겟 비율 계산
        bins = pd.cut(valid_series, bins=bin_edges, duplicates='drop')
        bin_probabilities = valid_target.groupby(bins).mean()

        return bin_edges, bin_probabilities

    def _generate_transformation_info(self, train_data):
        train_data = self._replace_unknown_values(train_data)

        bin_edges_dict = {}
        value_mapping_dict = {}
        bin_probabilities_dict = {}

        for column in train_data.columns:
            if column in self.exclude_cols or column == self.target_column:
                continue

            if pd.api.types.is_numeric_dtype(train_data[column]):
                bin_edges, bin_probabilities = self._calculate_probability_based_bins(
                    train_data[column],
                    train_data[self.target_column]
                )

                if bin_edges is not None:
                    bin_edges_dict[column] = bin_edges
                    bin_probabilities_dict[column] = bin_probabilities

                    # 확률에 따라 0~1 사이 값으로 매핑
                    sorted_probs = bin_probabilities.sort_values(ascending=False)
                    value_map = {}
                    for i, (bin_range, prob) in enumerate(sorted_probs.items()):
                        value_map[bin_range] = round((len(sorted_probs) - i - 1) / (len(sorted_probs) - 1), 2)

                    value_mapping_dict[column] = value_map
            else:
                category_probs = train_data[self.target_column].groupby(train_data[column]).mean()
                sorted_categories = category_probs.sort_values(ascending=False)

                # 카테고리별 확률을 5개 구간으로 나누어 매핑
                n_categories = len(sorted_categories)
                value_map = {}
                for i, (cat, prob) in enumerate(sorted_categories.items()):
                    value_map[cat] = round((n_categories - i - 1) / (n_categories - 1 if n_categories > 1 else 1), 2)

                value_mapping_dict[column] = value_map
                bin_probabilities_dict[column] = sorted_categories

        return bin_edges_dict, value_mapping_dict, bin_probabilities_dict

    def transform_data(self, data):
        result_data = self._replace_unknown_values(data)
        transformation_details = {}

        for column in result_data.columns:
            if column in self.exclude_cols or column == self.target_column:
                continue

            original_values = result_data[column].value_counts(dropna=False).to_dict()

            if pd.api.types.is_numeric_dtype(result_data[column]):
                if column in self.bin_edges_dict:
                    bins = pd.cut(result_data[column], bins=self.bin_edges_dict[column], duplicates='drop')
                    result_data[column] = bins.map(self.value_mapping_dict[column]).fillna(np.nan)

                    # 구간별 상세 정보 저장
                    bin_details = {
                        'bin_edges': self.bin_edges_dict[column].tolist(),
                        'bin_probabilities': self.bin_probabilities[column].to_dict(),
                        'value_mapping': self.value_mapping_dict[column]
                    }
            else:
                result_data[column] = result_data[column].map(self.value_mapping_dict[column]).fillna(np.nan)
                bin_details = {
                    'category_probabilities': self.bin_probabilities[column].to_dict(),
                    'value_mapping': self.value_mapping_dict[column]
                }

            transformed_values = result_data[column].value_counts(dropna=False).to_dict()

            transformation_details[column] = {
                'original_values': original_values,
                'transformed_values': transformed_values,
                'details': bin_details
            }

        self.transformation_details = transformation_details
        return result_data

    def print_transformation_details(self):
        for column, details in self.transformation_details.items():
            print(f"\n{'='*50}")
            print(f"{column} 변환 상세:")
            print(f"{'='*50}")

            print("\n1. 원본 값 분포:")
            for val, count in details['original_values'].items():
                print(f"  {val}: {count}")

            print("\n2. 변환된 값 분포:")
            for val, count in details['transformed_values'].items():
                print(f"  {val}: {count}")

            print("\n3. 변환 상세 정보:")
            if 'bin_edges' in details['details']:
                print("  [수치형 변수]")
                edges = details['details']['bin_edges']
                probs = details['details']['bin_probabilities']
                mappings = details['details']['value_mapping']

                print("\n  구간별 정보:")
                for i in range(len(edges)-1):
                    bin_range = pd.Interval(edges[i], edges[i+1])
                    if bin_range in probs:
                        prob = probs[bin_range]
                        mapped_value = mappings.get(bin_range, "N/A")
                        print(f"  구간 {i+1}: {edges[i]} ~ {edges[i+1]}")
                        print(f"    - 성공 확률: {prob:.3f}")
                        print(f"    - 매핑된 값: {mapped_value}")
            else:
                print("  [범주형 변수]")
                probs = details['details']['category_probabilities']
                mappings = details['details']['value_mapping']

                print("\n  카테고리별 정보:")
                for cat, prob in probs.items():
                    mapped_value = mappings.get(cat, "N/A")
                    print(f"  {cat}:")
                    print(f"    - 성공 확률: {prob:.3f}")
                    print(f"    - 매핑된 값: {mapped_value}")


transformer = DataTransformer(train_df, target_column='임신 성공 여부', exclude_cols=['ID'])
transformed_train_df = transformer.transform_data(train_df)
transformed_test_df = transformer.transform_data(test_df)

transformer.print_transformation_details()

import pandas as pd

# ID 컬럼을 제외한 모든 컬럼을 float로 변환
def convert_to_float(df):
    # ID 컬럼 이름 저장
    id_column = 'ID'

    # ID를 제외한 모든 컬럼 선택
    columns_to_convert = [col for col in df.columns if col != id_column]

    # 선택된 컬럼들을 float로 변환
    for col in columns_to_convert:
        try:
            df[col] = df[col].astype(float)
        except ValueError as e:
            print(f"Warning: Could not convert column '{col}' to float. Error: {e}")

    return df

transformed_train_df = convert_to_float(transformed_train_df)
transformed_test_df = convert_to_float(transformed_test_df)

transformed_test_df.to_csv('transformed_test_df.csv', index=False)
transformed_train_df.to_csv('transformed_train_df.csv', index=False)